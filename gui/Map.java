package gui;
import graphs.*;

import javax.swing.*;

import java.awt.*;
import java.awt.event.*;
import java.util.List;

public class Map extends JFrame {
	/**
	 * Autogenerated serialVersionUID
	 */
	private static final long serialVersionUID = 2309682835986284477L;
	private static final int SPACE_SIZE = 30, LEFT = 0, RIGHT = 1, DOWN = 2, UP = 3;
	Graph<Space> map = new ListGraph<>();
	JPanel display = new JPanel(),south;
	Player player = new Player(1*SPACE_SIZE,1*SPACE_SIZE,SPACE_SIZE);
	Ghost ghost[] = new Ghost[3];
	Space playerLocation = null, ghostLocation[] = new Space[3];
	int direction=0,attemptedDirection=0, playerSpeed = 0;
	int[] ghostDirection = new int[3];
	PlayerListener playerListener = new PlayerListener();
	boolean[] ghostMovable = new boolean[3]; 
	JLabel numberCaramels;
	public static boolean exit = false;
	DrawKeyImage left = new DrawKeyImage("left.png"), right = new DrawKeyImage("right.png"), down = new DrawKeyImage("down.png"), up = new DrawKeyImage("up.png") ,activeKeyPic;
	
	public Map() {
		Space[][] predefinedMap = PredefinedMap.createTextbasedMap(SPACE_SIZE);
		activeKeyPic = left;
		
		ghost[0] = new Ghost(8*SPACE_SIZE,8*SPACE_SIZE,SPACE_SIZE);
		ghost[1] = new Ghost(9*SPACE_SIZE,8*SPACE_SIZE,SPACE_SIZE);
		ghost[2] = new Ghost(9*SPACE_SIZE,9*SPACE_SIZE,SPACE_SIZE);
		for(int i=0;i<3;i++)
			ghostMovable[i]=false;
		display.add(ghost[0]);
		display.add(ghost[1]);
		display.add(ghost[2]);
		display.add(player);
		
		display.setLayout(null);
		display.setBackground(Color.BLACK);
		for(int i = 0; i<predefinedMap.length; i++)
			for(int j = 0; j<predefinedMap[0].length; j++){
				if (predefinedMap[i][j] != null){
					GameObject mapObject = (GameObject)predefinedMap[i][j];
					map.add(mapObject);
					display.add(mapObject);
				}
			}
		
		for(Space s1 : map.getNodes())
			for(Space s2 : map.getNodes())
				if(!s1.equals(s2) && (s1.isAdjacent(s2) && !s1.occupied() && !s2.occupied()) && map.getEdgeBetween(s1, s2) == null)
					map.connect(s1, s2, "step", 1);
		numberCaramels = new JLabel(""+Caramel.numberCaramels());
		south = new JPanel();
		south.setLayout(new FlowLayout());
		south.setBackground(Color.BLACK);
		JLabel text = new JLabel("Caramels left: ");
		text.setForeground(Color.WHITE);
		numberCaramels.setForeground(Color.WHITE);
		south.add(text);
		south.add(numberCaramels);
		south.add(activeKeyPic);
		add(south,BorderLayout.SOUTH);
		
		display.setPreferredSize(new Dimension(predefinedMap.length*SPACE_SIZE,(predefinedMap[0].length)*SPACE_SIZE));
		south.setPreferredSize(new Dimension(SPACE_SIZE,50));
		add(display);
		addKeyListener(playerListener);
		(new Movements()).start();
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		repaint();
		validate();
		pack();
//		setSize(predefinedMap.length*SPACE_SIZE,(predefinedMap[0].length+2)*SPACE_SIZE);
		setVisible(true);
	}
	public Space[] getPlayerLocation(){
		Space[] adjecentPlayerLocation = new Space[4];
		int left = 0, right = 1, down = 2, up = 3;
		int count = 0;
		
		for(Space space : map.getNodes()) {
			if(player.getOrigo().x>=space.getPoint().x && player.getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
				player.getOrigo().y>=space.getPoint().y && player.getOrigo().y<=space.getPoint().y+SPACE_SIZE){
				playerLocation = space;
				count++;
			}
			else if(player.getOrigo().x-SPACE_SIZE>=space.getPoint().x && player.getOrigo().x-SPACE_SIZE<=space.getPoint().x+SPACE_SIZE &&
				player.getOrigo().y>=space.getPoint().y && player.getOrigo().y<=space.getPoint().y+SPACE_SIZE){
				adjecentPlayerLocation[left] = space;
				count++;
			}
			else if(player.getOrigo().x+SPACE_SIZE>=space.getPoint().x && player.getOrigo().x+SPACE_SIZE<=space.getPoint().x+SPACE_SIZE &&
				player.getOrigo().y>=space.getPoint().y && player.getOrigo().y<=space.getPoint().y+SPACE_SIZE){
				adjecentPlayerLocation[right] = space;
				count++;
			}
			else if(player.getOrigo().x>=space.getPoint().x && player.getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
				player.getOrigo().y+SPACE_SIZE>=space.getPoint().y && player.getOrigo().y+SPACE_SIZE<=space.getPoint().y+SPACE_SIZE){
				adjecentPlayerLocation[down] = space;
				count++;
			}
			else if(player.getOrigo().x>=space.getPoint().x && player.getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
				player.getOrigo().y-SPACE_SIZE>=space.getPoint().y && player.getOrigo().y-SPACE_SIZE<=space.getPoint().y+SPACE_SIZE){
				adjecentPlayerLocation[up] = space;
				count++;
			}
			if(count>=5)
				break;
		}
		
		return adjecentPlayerLocation;
	}
	public Space[] getGhostLocation(int number){
		Space[] adjecentGhostLocation = new Space[4];
		int left = 0, right = 1, down = 2, up = 3;
		int count = 0;
		
		for(Space space : map.getNodes()) {
			if(ghost[number].getOrigo().x>=space.getPoint().x && ghost[number].getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
				ghost[number].getOrigo().y>=space.getPoint().y && ghost[number].getOrigo().y<=space.getPoint().y+SPACE_SIZE){
				ghostLocation[number] = space;
				count++;
			}
			if(ghost[number].getOrigo().x-SPACE_SIZE>=space.getPoint().x && ghost[number].getOrigo().x-SPACE_SIZE<=space.getPoint().x+SPACE_SIZE &&
				ghost[number].getOrigo().y>=space.getPoint().y && ghost[number].getOrigo().y<=space.getPoint().y+SPACE_SIZE){
				adjecentGhostLocation[left] = space;
				count++;
			}
			if(ghost[number].getOrigo().x+SPACE_SIZE>=space.getPoint().x && ghost[number].getOrigo().x+SPACE_SIZE<=space.getPoint().x+SPACE_SIZE &&
				ghost[number].getOrigo().y>=space.getPoint().y && ghost[number].getOrigo().y<=space.getPoint().y+SPACE_SIZE){
				adjecentGhostLocation[right] = space;
				count++;
			}
			if(ghost[number].getOrigo().x>=space.getPoint().x && ghost[number].getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
				ghost[number].getOrigo().y+SPACE_SIZE>=space.getPoint().y && ghost[number].getOrigo().y+SPACE_SIZE<=space.getPoint().y+SPACE_SIZE){
				adjecentGhostLocation[down] = space;
				count++;
			}
			if(ghost[number].getOrigo().x>=space.getPoint().x && ghost[number].getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
				ghost[number].getOrigo().y-SPACE_SIZE>=space.getPoint().y && ghost[number].getOrigo().y-SPACE_SIZE<=space.getPoint().y+SPACE_SIZE){
				adjecentGhostLocation[up] = space;
				count++;
			}
			if(count>=5)
				break;
		}
		
		return adjecentGhostLocation;
	}
	class PlayerListener extends KeyAdapter{
		public void keyPressed(KeyEvent kev){
			for(int i=0;i<3;i++)
				ghostMovable[i]=true;
			switch(kev.getKeyCode()){
			case KeyEvent.VK_LEFT:
				attemptedDirection = LEFT;
				south.remove(activeKeyPic);
				activeKeyPic = left;
				south.add(activeKeyPic);
				break;
			case KeyEvent.VK_RIGHT:
				attemptedDirection = RIGHT;
				south.remove(activeKeyPic);
				activeKeyPic = right;
				south.add(activeKeyPic);
				break;
			case KeyEvent.VK_DOWN:
				attemptedDirection = DOWN;
				south.remove(activeKeyPic);
				activeKeyPic = down;
				south.add(activeKeyPic);
				break;
			case KeyEvent.VK_UP:
				attemptedDirection = UP;
				south.remove(activeKeyPic);
				activeKeyPic = up;
				south.add(activeKeyPic);
				break;
			case KeyEvent.VK_ESCAPE:
				Map.exit = true;
				System.exit(JFrame.EXIT_ON_CLOSE);
				break;
			}
			south.validate();
			south.repaint();
		}
	}
	public class Movements extends Thread {
	    public void run() {
	    	boolean caught=false;
	    	while(!caught && Caramel.numberCaramels()>0){
	    		try{
		    		Movements.sleep(20);
		    	}catch(InterruptedException ie){}
		    	int count = 0;
				for(Space space : map.getNodes()) {
			    	if(ghost[0].getOrigo().x>=space.getPoint().x && ghost[0].getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
							ghost[0].getOrigo().y>=space.getPoint().y && ghost[0].getOrigo().y<=space.getPoint().y+SPACE_SIZE){
						ghostLocation[0] = space;
						count++;
					}
					if(ghost[1].getOrigo().x>=space.getPoint().x && ghost[1].getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
							ghost[1].getOrigo().y>=space.getPoint().y && ghost[1].getOrigo().y<=space.getPoint().y+SPACE_SIZE){
						ghostLocation[1] = space;
						count++;
					}
					if(ghost[2].getOrigo().x>=space.getPoint().x && ghost[2].getOrigo().x<=space.getPoint().x+SPACE_SIZE &&
							ghost[2].getOrigo().y>=space.getPoint().y && ghost[2].getOrigo().y<=space.getPoint().y+SPACE_SIZE){
						ghostLocation[2] = space;
						count++;
					}
					if(count>=3)
						break;
				}
				for(int i=0; i<3; i++){
					moveGhost(i);
					if((int)(Math.random()*40)==0)
						moveGhost(i);
				}
				for(Ghost g : ghost)
					if(Math.sqrt(Math.pow(g.getPoint().x-player.getPoint().x,2)+Math.pow(g.getPoint().y-player.getPoint().y,2)) < SPACE_SIZE){
						Map.this.removeKeyListener(playerListener);
						JOptionPane.showMessageDialog(Map.this, "You have been caught!", "End message", JOptionPane.INFORMATION_MESSAGE);
						caught = true;
					}
				movePlayer();
				if(playerSpeed>0){
					movePlayer();
					playerSpeed--;
				}
		    	validate();
				repaint();
	    	}
	    	if(Caramel.numberCaramels()<=0)
	    		JOptionPane.showMessageDialog(Map.this, "You have mastered the game!", "Winner message", JOptionPane.INFORMATION_MESSAGE);
	    	System.exit(JFrame.EXIT_ON_CLOSE);
	    }
	    public void movePlayer(){
	    	Space[] adjecentPlayerLocation = getPlayerLocation();
			if (!adjecentPlayerLocation[attemptedDirection].occupied()){
				if(attemptedDirection<2 && player.getPoint().y%SPACE_SIZE == 0)
					direction = attemptedDirection;
				if(attemptedDirection>1 && player.getPoint().x%SPACE_SIZE == 0)
					direction = attemptedDirection;
			}
			if(!(adjecentPlayerLocation[direction].occupied() && player.getPoint().x%SPACE_SIZE == 0 && player.getPoint().y%SPACE_SIZE == 0)){
				player.moveDirection(direction,SPACE_SIZE);
				if(((Floor)playerLocation).contains() != null){
					if((int)(Math.random()*10)==1)
						playerSpeed=15;
					player.eat();
					((Floor)playerLocation).empty();
					numberCaramels.setText(""+Caramel.numberCaramels());
				}
			}
	    }
	    public void moveGhost(int number){
	    	boolean movable = true;
			getPlayerLocation();
			List<Edge<Space>> path = GraphMethods.getPath(ghostLocation[number], playerLocation, map);
			if (path != null && path.size()>0){
				for(Space g : ghost)
					if(Math.abs(path.get(0).getDestination().getPoint().x-g.getPoint().x) < SPACE_SIZE && Math.abs(path.get(0).getDestination().getPoint().y-g.getPoint().y) < SPACE_SIZE && !g.equals(ghost[number]))
						movable = false;
				if(movable && ghostMovable[number]){
//					ghost[i].move(path.get(0).getDestination().getPoint());
					Point point = path.get(0).getDestination().getPoint();
					if(point.x < ghost[number].getPoint().x && ghost[number].getPoint().y%SPACE_SIZE == 0)
						ghostDirection[number] = LEFT;
					if(point.x > ghost[number].getPoint().x && ghost[number].getPoint().y%SPACE_SIZE == 0)
						ghostDirection[number] = RIGHT;
					if(point.y > ghost[number].getPoint().y && ghost[number].getPoint().x%SPACE_SIZE == 0)
						ghostDirection[number] = DOWN;
					if(point.y < ghost[number].getPoint().y && ghost[number].getPoint().x%SPACE_SIZE == 0)
						ghostDirection[number] = UP;
					ghost[number].moveDirection(ghostDirection[number],SPACE_SIZE);
				}
			}
	    }
	}
}
